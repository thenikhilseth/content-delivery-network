"use strict";
// Copyright 2017 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const mime_types_1 = require("mime-types");
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const fsStat = util_1.promisify(fs_1.default.stat);
const asset_cache_1 = require("./asset-cache");
const client_cache_checker_1 = require("./client-cache-checker");
// TODO(jinwoo): Tune these default parameters.
const DEFAULT_CACHE_CONFIG = {
    warmupDuration: 500,
    promotionRatio: 0.8,
    demotionRatio: 0.2,
    minimumRequests: 1,
};
class AutoPush {
    constructor(rootDir, cacheConfig = DEFAULT_CACHE_CONFIG) {
        this.rootDir = rootDir;
        this.assetCache = new asset_cache_1.AssetCache(cacheConfig);
    }
    addCacheHeaders(headers, stats, filePath) {
        headers['content-type'] = mime_types_1.lookup(filePath);
        headers['cache-control'] = 'public, max-age=0';
        headers['last-modified'] = stats.mtime.toUTCString();
    }
    recordRequestPath(session, reqPath, isStatic) {
        this.assetCache.recordRequestPath(session, reqPath, isStatic);
    }
    async preprocessRequest(reqPath, stream, cacheCookie) {
        const cacheChecker = cacheCookie ?
            client_cache_checker_1.ClientCacheChecker.deserialize(cacheCookie) :
            new client_cache_checker_1.ClientCacheChecker();
        // Calculate the auto-push list before sending the response to be able to
        // set the bloom filter cookie correctly that contains the auto-pushed
        // assets as well as the original asset. Otherwise we'll auto-push assets
        // that browser already has in future responses.
        const pushList = await this.getAutoPushList(reqPath, stream, cacheChecker);
        cacheChecker.addPath(reqPath);
        const newCacheCookie = cacheChecker.serialize();
        return {
            newCacheCookie,
            pushFn: () => this.push(stream, pushList),
        };
    }
    async getAutoPushList(reqPath, stream, cacheChecker) {
        const result = [];
        if (!stream.pushAllowed)
            return result;
        // Do not auto-push more than the window size. Use remoteWindowSize, which
        // designates the remote window size for a connection, which means the
        // amount of data we can send without window size update.
        // FIXME: The response size of the original request must also be considered.
        // Ignore for now.
        const windowSize = stream.session.state.remoteWindowSize;
        if (!windowSize)
            return result;
        let pushedSize = 0;
        for (const asset of this.assetCache.getAssetsForPath(reqPath)) {
            if (cacheChecker.mayHavePath(asset)) {
                continue;
            }
            if (pushedSize > windowSize)
                break;
            try {
                const stats = await fsStat(path_1.default.join(this.rootDir, asset));
                if (pushedSize + stats.size > windowSize) {
                    continue;
                }
                result.push(asset);
                cacheChecker.addPath(asset);
                pushedSize += stats.size;
            }
            catch (err) {
                // fsStat() failed, just skip.
            }
        }
        return result;
    }
    async push(stream, pushList) {
        const pushPromises = pushList.map((asset) => {
            return new Promise((resolve, reject) => {
                const pushFile = (pushStream) => {
                    const filePath = path_1.default.join(this.rootDir, asset);
                    const onFinish = () => {
                        pushStream.removeListener('error', onError);
                        resolve();
                    };
                    const onError = (err) => {
                        stream.emit('pushError', err);
                        pushStream.removeListener('finish', onFinish);
                        pushStream.end();
                        reject(err);
                    };
                    pushStream.once('error', onError);
                    pushStream.once('finish', onFinish);
                    pushStream.respondWithFile(filePath, undefined, {
                        statCheck: (stats, headers) => {
                            this.addCacheHeaders(headers, stats, filePath);
                        },
                        onError: (err) => {
                            pushStream.removeListener('error', onError);
                            onError(err);
                        },
                    });
                };
                stream.pushStream({ ':path': asset, 'content-type': mime_types_1.lookup(asset) }, (err, pushStream) => {
                    if (err) {
                        return reject(err);
                    }
                    pushFile(pushStream);
                });
            });
        });
        await Promise.all(pushPromises);
    }
}
exports.AutoPush = AutoPush;
//# sourceMappingURL=index.js.map